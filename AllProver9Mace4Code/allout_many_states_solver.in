set(arithmetic).
assign(domain_size,7). 
assign(max_models,-1).

formulas(usable).

% ds = represents the size of the extended grid
ds = domain_size + -1.

% the number of states in which a cell can be
noStates = 3.

end_of_list.

% Lights out problem generalized for the case when one cell can have more than 2 states.
% b(x,y) represent the initial state of the cell.
% c(x,y) represent the number of times a cell's state is changed.

formulas(assumptions).

% extend the grid with 1 more column and row which are not considered in the solution.
(x = 0 | x = ds | y = 0 | y = ds) -> b(x,y) = 0 & c(x,y) = 0.

% each light should be switched less than the nr of states in total, otherwise it would end up in its initial state => eliminate redundant moves.
c(x,y) < noStates.

% after applying a number of moves(switches) on the current and neighbour cells, the final state of the current cell should be the state 0.
% that means, if the cell b(x,y) should be changed either directly or through its neighbours if it is not in the correct state.
(x > 0 & x < ds & y > 0 & y < ds & xp = x + -1 & yp = y + -1 & xs = x + 1 & ys = y + 1) -> (b(x,y) + c(x,y) + c(xp,y) + c(x,yp) + c(xs,y) + c(x,ys)) mod noStates = 0.

end_of_list.

% grid: top-left:(0,0) and bottom-right:(Ds,Ds)

formulas(sample).

b(1,1) = 0.
b(1,2) = 1.
b(1,3) = 1.
b(1,4) = 0.
b(1,5) = 2.
b(2,1) = 1.
b(2,2) = 1.
b(2,3) = 1.
b(2,4) = 0.
b(2,5) = 2.
b(3,1) = 0.
b(3,2) = 0.
b(3,3) = 0.
b(3,4) = 1.
b(3,5) = 2.
b(4,1) = 2.
b(4,2) = 2.
b(4,3) = 1.
b(4,4) = 2.
b(4,5) = 0.
b(5,1) = 0.
b(5,2) = 0.
b(5,3) = 2.
b(5,4) = 1.
b(5,5) = 2.

end_of_list.

formulas(goals).
end_of_list.


